<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snakes & Ladders: Quad Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@400;700;900&display=swap');

        :root {
            --bg-color: #1a1a2e;
            --board-bg: #16213e;
            --cell-1: #e94560;
            --cell-2: #0f3460;
            --text-color: #fff;

            --p1-color: #ff4757;
            /* Red */
            --p2-color: #2ed573;
            /* Green */
            --p3-color: #1e90ff;
            /* Blue */
            --p4-color: #ffa502;
            /* Yellow */

            --glass-bg: rgba(255, 255, 255, 0.1);
            --glass-border: rgba(255, 255, 255, 0.2);
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Outfit', sans-serif;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            gap: 40px;
            align-items: flex-start;
            padding: 20px;
        }

        /* --- Game Board --- */
        .board-wrapper {
            position: relative;
            padding: 20px;
            background: var(--board-bg);
            border-radius: 20px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            border: 1px solid var(--glass-border);
        }

        .board {
            display: grid;
            grid-template-columns: repeat(10, 60px);
            grid-template-rows: repeat(10, 60px);
            gap: 2px;
            position: relative;
            z-index: 1;
        }

        .cell {
            background: rgba(255, 255, 255, 0.05);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: 700;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            position: relative;
        }

        .cell:nth-child(odd) {
            background: rgba(255, 255, 255, 0.08);
        }

        /* Canvas Overlay for Snakes & Ladders */
        #connections {
            position: absolute;
            top: 20px;
            /* Match padding of wrapper */
            left: 20px;
            width: 620px;
            /* 10 * 60 + 9 * 2 (approx gap) though grid gap logic varies. Let's force size via JS logic or precise layout */
            height: 620px;
            pointer-events: none;
            z-index: 2;
        }

        /* --- Players --- */
        .player-token {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            position: absolute;
            z-index: 10;
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            border: 2px solid white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            font-weight: bold;
            color: #000;
        }

        /* Different positions within the cell to avoid overlap */
        .p-offset-0 {
            transform: translate(-10px, -10px);
        }

        .p-offset-1 {
            transform: translate(10px, -10px);
        }

        .p-offset-2 {
            transform: translate(-10px, 10px);
        }

        .p-offset-3 {
            transform: translate(10px, 10px);
        }

        /* --- UI Controls --- */
        .controls {
            width: 300px;
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            padding: 30px;
            border-radius: 20px;
            border: 1px solid var(--glass-border);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        h1 {
            margin: 0;
            font-size: 32px;
            line-height: 1.1;
            background: linear-gradient(45deg, #ff4757, #ffa502);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: transparent;
        }

        .player-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .player-card {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.2);
            transition: all 0.3s;
            border-left: 4px solid transparent;
        }

        .player-card.active {
            background: rgba(255, 255, 255, 0.1);
            border-left-color: currentColor;
            transform: translateX(10px);
        }

        .dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .dice-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }

        #diceBtn {
            width: 80px;
            height: 80px;
            background: #fff;
            border-radius: 12px;
            border: none;
            font-size: 32px;
            font-weight: 900;
            color: #1a1a2e;
            cursor: pointer;
            box-shadow: 0 10px 0 #bdc3c7, 0 15px 20px rgba(0, 0, 0, 0.2);
            transition: all 0.1s;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #diceBtn:active {
            transform: translateY(10px);
            box-shadow: 0 0 0 #bdc3c7, 0 5px 5px rgba(0, 0, 0, 0.1);
        }

        #diceBtn:disabled {
            background: #7f8c8d;
            color: #95a5a6;
            box-shadow: none;
            cursor: not-allowed;
            transform: translateY(10px);
        }

        .status {
            text-align: center;
            min-height: 1.5em;
            font-size: 18px;
            color: #dfe6e9;
        }

        /* Winner Overlay */
        .winner-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(5px);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        .winner-overlay.show {
            opacity: 1;
            pointer-events: all;
        }

        .winner-card {
            background: #fff;
            padding: 40px 60px;
            border-radius: 20px;
            text-align: center;
            transform: scale(0.8);
            transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .winner-overlay.show .winner-card {
            transform: scale(1);
        }

        .winner-card h1 {
            font-size: 48px;
            margin: 0 0 20px 0;
            text-transform: uppercase;
        }

        .winner-card p {
            color: #333;
            font-size: 18px;
            margin-bottom: 30px;
        }

        .winner-card button {
            padding: 12px 30px;
            font-size: 18px;
            background: #1a1a2e;
            color: #fff;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s;
            font-family: inherit;
            font-weight: bold;
        }

        .winner-card button:hover {
            transform: scale(1.05);
        }

        /* Confetti */
        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #f00;
            animation: fall linear forwards;
        }

        @keyframes fall {
            to {
                transform: translateY(100vh) rotate(720deg);
            }
        }
    </style>
</head>

<body>

    <div class="container">
        <div class="board-wrapper">
            <canvas id="connections"></canvas>
            <div class="board" id="board">
                <!-- Cells generated by JS -->
            </div>
            <!-- Player tokens injected here -->
        </div>

        <div class="controls">
            <h1>Snake &<br>Ladders</h1>

            <div class="player-list">
                <div class="player-card active" style="color: var(--p1-color);" id="card-0">
                    <div class="dot" style="background: var(--p1-color);"></div>
                    <span>Player 1</span>
                    <span id="pos-0" style="margin-left: auto; opacity: 0.7;">1</span>
                </div>
                <div class="player-card" style="color: var(--p2-color);" id="card-1">
                    <div class="dot" style="background: var(--p2-color);"></div>
                    <span>Player 2</span>
                    <span id="pos-1" style="margin-left: auto; opacity: 0.7;">1</span>
                </div>
                <div class="player-card" style="color: var(--p3-color);" id="card-2">
                    <div class="dot" style="background: var(--p3-color);"></div>
                    <span>Player 3</span>
                    <span id="pos-2" style="margin-left: auto; opacity: 0.7;">1</span>
                </div>
                <div class="player-card" style="color: var(--p4-color);" id="card-3">
                    <div class="dot" style="background: var(--p4-color);"></div>
                    <span>Player 4</span>
                    <span id="pos-3" style="margin-left: auto; opacity: 0.7;">1</span>
                </div>
            </div>

            <div class="status" id="statusMsg">Player 1's Turn</div>

            <div class="dice-container">
                <button id="diceBtn" onclick="takeTurn()">üé≤</button>
            </div>
        </div>
    </div>

    <!-- Winner Overlay -->
    <div id="winnerOverlay" class="winner-overlay">
        <div class="winner-card">
            <h1 id="winnerText">PLAYER 1 WINS!</h1>
            <p>Congratulations on reaching the top!</p>
            <button onclick="location.reload()">Play Again</button>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        const boardSize = 10;
        const boardEl = document.getElementById('board');
        const boardWrap = document.querySelector('.board-wrapper');
        const canvas = document.getElementById('connections');
        const ctx = canvas.getContext('2d');

        // Local state mirroring server
        let players = [];
        let myIndex = -1;
        let isAnimating = false;

        // Config (Still needed for visuals)
        const snakes = {
            16: 6, 47: 26, 49: 11, 56: 53, 62: 19, 64: 60, 87: 24, 93: 73, 95: 75, 98: 78
        };
        const ladders = {
            1: 38, 4: 14, 9: 31, 21: 42, 28: 84, 36: 44, 51: 67, 71: 91, 80: 100
        };
        const cellSize = 62;

        // --- Socket Events ---

        socket.on('init', (data) => {
            myIndex = data.myIndex;
            players = data.players;

            // Re-render UI
            updateUI(data.currentTurn);

            const statusEl = document.getElementById("statusMsg");
            statusEl.innerText = `You are Player ${myIndex + 1}`;
            statusEl.style.color = players[myIndex].color;

            // Re-draw tokens
            document.querySelectorAll('.player-token').forEach(e => e.remove());
            createPlayers();
        });

        socket.on('playerUpdate', (serverPlayers) => {
            // Sync positions without animation (e.g. initial load or reconnection)
            players = serverPlayers;
            players.forEach((p, i) => {
                updatePlayerPos(i);
            });
        });

        socket.on('diceRolled', async (data) => {
            // Animate dice for everyone
            const diceBtn = document.getElementById('diceBtn');
            const diceFaces = ['‚öÄ', '‚öÅ', '‚öÇ', '‚öÉ', '‚öÑ', '‚öÖ'];
            isAnimating = true;
            diceBtn.disabled = true;

            // Visual roll
            for (let i = 0; i < 10; i++) {
                const r = Math.floor(Math.random() * 6);
                diceBtn.innerText = diceFaces[r];
                await new Promise(r => setTimeout(r, 50));
            }
            // Show actual roll
            diceBtn.innerText = diceFaces[data.val - 1];
        });

        socket.on('turnResult', async (data) => {
            // data: { playerIdx, newPos, message, nextTurn, rollVal, winner, voidTurn }
            const pIdx = data.playerIdx;
            const player = players[pIdx];
            const statusEl = document.getElementById("statusMsg");

            statusEl.innerText = data.message;
            statusEl.style.color = "#dfe6e9";

            // Update local pos
            player.pos = data.newPos;
            updatePlayerPos(pIdx);

            if (data.winner !== null) {
                statusEl.innerText = `PLAYER ${data.winner + 1} WINS!`;
                statusEl.style.color = "#f1c40f";

                if (data.winner === myIndex) {
                    alert("YOU WON!");
                } else {
                    alert(`Player ${data.winner + 1} Won!`);
                }

                // Optional: Effect
                document.body.style.backgroundColor = players[data.winner].color;
                return;
            }

            // Update Active Card logic
            document.querySelectorAll('.player-card').forEach(c => c.classList.remove('active'));
            // Check if card exists for nextTurn (safety)
            if (document.getElementById(`card-${data.nextTurn}`)) {
                document.getElementById(`card-${data.nextTurn}`).classList.add('active');
            }

            // Enable dice if it's my turn
            const diceBtn = document.getElementById('diceBtn');
            isAnimating = false;

            if (data.nextTurn === myIndex) {
                statusEl.innerText = "YOUR TURN!";
                statusEl.style.color = "#fff";
                diceBtn.disabled = false;
                diceBtn.innerText = "üé≤";
            } else {
                statusEl.innerText = `Player ${data.nextTurn + 1}'s Turn`;
                diceBtn.disabled = true;
            }
        });

        socket.on('roomFull', () => {
            alert("Room is full! Spectator mode.");
        });


        // --- Helper Functions (Same as before) ---

        function getCoords(num) {
            if (num < 1) num = 1;
            if (num > 100) num = 100;
            let rowInverse = Math.floor((num - 1) / 10);
            let row = 9 - rowInverse;
            let col = (num - 1) % 10;
            let rowFromBottom = rowInverse;
            if (rowFromBottom % 2 === 1) col = 9 - col;
            const x = 20 + col * cellSize + 30;
            const y = 20 + row * cellSize + 30;
            return { x, y };
        }

        function createBoard() {
            boardEl.innerHTML = '';
            for (let r = 0; r < 10; r++) {
                const rowFromBottom = 9 - r;
                const isRightToLeft = (rowFromBottom % 2 === 1);
                const startStr = isRightToLeft ? (rowFromBottom * 10 + 10) : (rowFromBottom * 10 + 1);

                for (let c = 0; c < 10; c++) {
                    let num;
                    if (isRightToLeft) num = startStr - c;
                    else num = startStr + c;

                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.innerText = num;
                    if (snakes[num]) cell.style.background = 'rgba(231, 76, 60, 0.2)';
                    if (ladders[num]) cell.style.background = 'rgba(46, 204, 113, 0.2)';
                    boardEl.appendChild(cell);
                }
            }
        }

        function createPlayers() {
            players.forEach((p, idx) => {
                const el = document.createElement('div');
                el.className = `player-token p-offset-${idx}`;
                el.id = `p-token-${idx}`;
                el.style.backgroundColor = p.color;
                el.innerText = `P${idx + 1}`;
                boardWrap.appendChild(el);
                updatePlayerPos(idx);
            });
        }

        function updatePlayerPos(idx) {
            if (!players[idx]) return;
            const p = players[idx];
            let el = document.getElementById(`p-token-${idx}`);
            if (!el) {
                el = document.createElement('div');
                el.className = `player-token p-offset-${idx}`;
                el.id = `p-token-${idx}`;
                el.style.backgroundColor = p.color;
                el.innerText = `P${idx + 1}`;
                boardWrap.appendChild(el);
            }

            const coords = getCoords(p.pos);
            el.style.left = (coords.x - 12.5) + 'px';
            el.style.top = (coords.y - 12.5) + 'px';
            document.getElementById(`pos-${idx}`).innerText = p.pos;
        }

        function updateUI(turnIdx) {
            document.querySelectorAll('.player-card').forEach(c => c.classList.remove('active'));
            if (document.getElementById(`card-${turnIdx}`)) {
                document.getElementById(`card-${turnIdx}`).classList.add('active');
            }

            const diceBtn = document.getElementById('diceBtn');
            if (turnIdx === myIndex) {
                diceBtn.disabled = false;
                diceBtn.innerText = "üé≤";
            } else {
                diceBtn.disabled = true;
            }
        }

        function drawConnections() {
            canvas.width = 620; canvas.height = 620;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let [start, end] of Object.entries(snakes)) drawSnake(parseInt(start), end);
            for (let [start, end] of Object.entries(ladders)) drawLadder(parseInt(start), end);
        }

        function drawSnake(startNum, endNum) {
            const start = getCoords(startNum); // Head
            const end = getCoords(endNum);     // Tail

            const sx = start.x - 20;
            const sy = start.y - 20;
            const ex = end.x - 20;
            const ey = end.y - 20;

            const dist = Math.hypot(ex - sx, ey - sy);
            const angle = Math.atan2(ey - sy, ex - sx);

            // Wavier control points for "slithery" look
            const cp1x = sx + Math.cos(angle + Math.PI / 2) * dist * 0.35;
            const cp1y = sy + Math.sin(angle + Math.PI / 2) * dist * 0.35;
            const cp2x = ex + Math.cos(angle - Math.PI / 2) * dist * 0.35;
            const cp2y = ey + Math.sin(angle - Math.PI / 2) * dist * 0.35;

            // --- Body ---
            ctx.lineCap = 'round';

            // 1. Outer Glow (Toxic Green)
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, ex, ey);
            ctx.lineWidth = 18;
            ctx.strokeStyle = 'rgba(46, 213, 115, 0.4)';
            ctx.stroke();

            // 2. Base Scales (Dark Slate)
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, ex, ey);
            ctx.lineWidth = 14;
            ctx.strokeStyle = '#2d3436';
            ctx.stroke();

            // 3. Warning Pattern (Crimson Stripes)
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, ex, ey);
            ctx.lineWidth = 6;
            ctx.strokeStyle = '#c0392b';
            ctx.setLineDash([5, 12]);
            ctx.stroke();
            ctx.setLineDash([]); // Reset

            // 4. Spine highlight
            ctx.beginPath();
            ctx.moveTo(sx, sy);
            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, ex, ey);
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#55efc4';
            ctx.stroke();

            // --- HEAD (Scary Viper) ---
            ctx.save();

            // Tangent alignment
            const tanAngle = Math.atan2(cp1y - sy, cp1x - sx);

            ctx.translate(sx, sy);
            ctx.rotate(tanAngle);

            // Viper Head Shape (Relative to Neck at 0,0)
            // Pointing -X (Backwards/Out from curve start)
            ctx.beginPath();
            ctx.fillStyle = '#2d3436';

            ctx.moveTo(0, 6);   // Neck Top
            ctx.lineTo(-10, 12); // Jaw Flare Top
            ctx.lineTo(-24, 6);  // Eye Ridge Top
            ctx.lineTo(-30, 0);  // Snout Tip
            ctx.lineTo(-24, -6); // Eye Ridge Bot
            ctx.lineTo(-10, -12); // Jaw Flare Bot
            ctx.lineTo(0, -6);   // Neck Bot
            ctx.closePath();
            ctx.fill();

            // Head Outline
            ctx.strokeStyle = '#55efc4';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Eyes (Slits)
            ctx.fillStyle = '#f1c40f'; // Yellow Sclera
            ctx.beginPath();
            ctx.ellipse(-16, 5, 4, 2, -Math.PI / 6, 0, Math.PI * 2); // Top Eye
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(-16, -5, 4, 2, Math.PI / 6, 0, Math.PI * 2); // Bot Eye
            ctx.fill();

            // Pupils (Red Vertical)
            ctx.fillStyle = '#c0392b';
            ctx.beginPath();
            ctx.rect(-17, 3, 2, 4);
            ctx.rect(-17, -7, 2, 4);
            ctx.fill();

            // Fangs (Sharp White)
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.moveTo(-20, 3); ctx.lineTo(-20, 10); ctx.lineTo(-24, 3); // Top Fang
            ctx.moveTo(-20, -3); ctx.lineTo(-20, -10); ctx.lineTo(-24, -3); // Bot Fang
            ctx.fill();

            // Tongue
            ctx.strokeStyle = '#e17055';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-30, 0);
            ctx.lineTo(-45, 4); // Fork 1
            ctx.moveTo(-30, 0);
            ctx.lineTo(-45, -4); // Fork 2
            ctx.stroke();

            ctx.restore();
        }

        function drawLadder(startNum, endNum) {
            const start = getCoords(startNum); const end = getCoords(endNum);
            const sx = start.x - 20, sy = start.y - 20, ex = end.x - 20, ey = end.y - 20;
            const width = 20; const angle = Math.atan2(ey - sy, ex - sx); const perp = angle + Math.PI / 2;
            const ox = Math.cos(perp) * width / 2; const oy = Math.sin(perp) * width / 2;

            ctx.beginPath(); ctx.moveTo(sx - ox, sy - oy); ctx.lineTo(ex - ox, ey - oy); ctx.moveTo(sx + ox, sy + oy); ctx.lineTo(ex + ox, ey + oy);
            ctx.lineWidth = 6; ctx.strokeStyle = '#e67e22'; ctx.lineCap = 'butt'; ctx.stroke();
            const dist = Math.hypot(ex - sx, ey - sy); const steps = Math.floor(dist / 30);
            ctx.beginPath();
            for (let i = 1; i < steps; i++) {
                const t = i / steps; const cx = sx + (ex - sx) * t; const cy = sy + (ey - sy) * t;
                ctx.moveTo(cx - ox, cy - oy); ctx.lineTo(cx + ox, cy + oy);
            }
            ctx.lineWidth = 4; ctx.stroke();
        }

        async function takeTurn() {
            if (isAnimating) return;
            // request server
            if (myIndex !== -1) {
                socket.emit('requestRoll');
            }
        }

        function createConfetti() {
            const colors = ['#ff4757', '#2ed573', '#1e90ff', '#ffa502', '#f1c40f', '#e84393'];
            for (let i = 0; i < 100; i++) {
                const c = document.createElement('div');
                c.classList.add('confetti');
                c.style.left = Math.random() * 100 + 'vw';
                c.style.top = -10 + 'px';
                c.style.background = colors[Math.floor(Math.random() * colors.length)];
                c.style.animationDuration = (Math.random() * 3 + 2) + 's';
                c.style.opacity = Math.random();
                document.body.appendChild(c);
            }
        }

        // Start
        createBoard();
        drawConnections();
        // createPlayers() called on init

    </script>
</body>

</html>